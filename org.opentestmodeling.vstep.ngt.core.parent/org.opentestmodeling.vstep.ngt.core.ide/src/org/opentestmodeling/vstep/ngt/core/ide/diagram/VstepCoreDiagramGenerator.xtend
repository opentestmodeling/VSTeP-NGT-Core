package org.opentestmodeling.vstep.ngt.core.ide.diagram

import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.sprotty.LayoutOptions
import org.eclipse.sprotty.SEdge
import org.eclipse.sprotty.SGraph
import org.eclipse.sprotty.SLabel
import org.eclipse.sprotty.SModelElement
import org.eclipse.sprotty.SNode
import org.eclipse.sprotty.SPort
import org.eclipse.sprotty.xtext.IDiagramGenerator
import org.eclipse.sprotty.xtext.SIssueMarkerDecorator
import org.eclipse.sprotty.xtext.tracing.ITraceProvider
import org.opentestmodeling.vstep.ngt.core.language.Model
import org.opentestmodeling.vstep.ngt.core.language.TestViewpoint
import org.opentestmodeling.vstep.ngt.core.language.Relation
import org.opentestmodeling.vstep.ngt.core.language.TargetRef
import org.opentestmodeling.vstep.ngt.core.language.ViewpointRef
import org.opentestmodeling.vstep.ngt.core.language.LanguagePackage
import org.opentestmodeling.vstep.ngt.core.language.TestTarget
import org.opentestmodeling.vstep.ngt.core.language.TestContainer
import org.opentestmodeling.vstep.ngt.core.language.NodeConnection
import org.opentestmodeling.vstep.ngt.core.language.Inheritance
import org.opentestmodeling.vstep.ngt.core.language.Dependency
import org.eclipse.emf.common.util.EList
import org.opentestmodeling.vstep.ngt.core.language.TestElement
import org.eclipse.sprotty.SCompartment
import org.opentestmodeling.vstep.ngt.core.language.Inheritance1
import org.opentestmodeling.vstep.ngt.core.language.Inheritance2

class VstepCoreDiagramGenerator implements IDiagramGenerator {
	
	@Inject extension ITraceProvider
	@Inject extension SIssueMarkerDecorator
	
	override generate(Context context) {
		(context.resource.contents.head as Model).toSGraph(context)
	}
	
	def toSGraph(Model model, extension Context context) {
		new SGraph [
			id = idCache.uniqueId(model, model.toString)
			children = model.testElements.buildContainer(context)
		].traceAndMark(model, context)
	}

    def buildContainer(EList<TestElement> elements, extension Context context) {
    	(elements.filter[!(it instanceof NodeConnection)].map[toSNode(context)]
			+ elements.filter(NodeConnection).map[toSEdge(context)]).toList
    }

	def dispatch SNode toSNode(TestContainer container, extension Context context) {
		val theId = idCache.uniqueId(container, container.name);
		new SNode [
			id = theId
			type = 'node.container'
			layout = 'vbox'
			layoutOptions = new LayoutOptions [
				paddingTop = 0.0
				paddingBottom = 0.0
				paddingLeft = 0.0
				paddingRight = 0.0
				VGap = 0.0
				HGap = 0.0
			]
			children = #[
				new SLabel [
					id = idCache.uniqueId(theId + '.label')
					text = container.name
					layoutOptions = new LayoutOptions [
						HAlign = 'left'
					] 
				].trace(container),
				new SCompartment [
					id = idCache.uniqueId(theId + '.container')
					children = container.elements.buildContainer(context)
					layoutOptions = new LayoutOptions [
						paddingTop = 10.0
						paddingBottom = 10.0
						paddingLeft = 10.0
						paddingRight = 10.0
					]
				].trace(container)
			]
		].traceAndMark(container, context)
	}

	def dispatch SNode toSNode(TestTarget target, extension Context context) {
 		val theId = idCache.uniqueId(target, target.name);
		new SNode [
			id = theId
			type = "node.target"

			children = #[
				new SCompartment[
					children = newArrayList
					layout = 'vbox'
					id = idCache.uniqueId(theId + '.comp1')
					if (target.stereotype !== null) {
						children += new SLabel [
							id = idCache.uniqueId(theId + '.stereotype')
							text = target.stereotype
						]
					}
					children += new SCompartment[
						type = 'comp.target'
						id = idCache.uniqueId(theId + '.comp2')
						layout = 'vbox'
						children = #[
							new SLabel [
								id = idCache.uniqueId(theId + '.label')
								text = target.name.substring(1, target.name.length - 1)	
							]
						]
					]
				].trace(target)
			]

			layout = 'stack'
			layoutOptions = new LayoutOptions [
				paddingTop = 5.0
				paddingBottom = 5.0
				paddingLeft = 5.0
				paddingRight = 5.0
				
			]
		].traceAndMark(target, context)
	}

	def dispatch SNode toSNode(TestViewpoint viewpoint, extension Context context) {
		val theId = idCache.uniqueId(viewpoint, viewpoint.name) 
		(new SNode [
			id = theId
			type = 'node.viewpoint'
			layout = 'vbox'

			children = newArrayList
			if (viewpoint.stereotype !== null) {
				children += new SLabel [
					id = idCache.uniqueId(theId + '.stereotype')
					text = viewpoint.stereotype
				].trace(viewpoint)
			}
			children +=	 new SPort [
				id = idCache.uniqueId(theId + '.newTransition')
			].trace(viewpoint)
			children += new SCompartment[
				id = idCache.uniqueId(theId + '.box')
				type = 'comp.box'
				layout = 'vbox'
				layoutOptions = new LayoutOptions[
					paddingLeft = 0.0
					paddingRight = 0.0
					paddingTop = 0.0
					paddingBottom = 0.0
					HGap = 0.0
					VGap = 0.0
					HAlign = 'center'
				]

				children = #[
					new SLabel [
						id = idCache.uniqueId(theId + '.name')
						text = viewpoint.name.substring(1, viewpoint.name.length - 1) 
					].trace(viewpoint),
					new SCompartment[
						id = idCache.uniqueId(theId + '.comp')
						type = 'comp.box'
						layout = 'hbox'
						layoutOptions = new LayoutOptions[
							paddingLeft = 0.0
							paddingRight = 0.0
							paddingTop = 0.0
							paddingBottom = 0.0
							HGap = 0.0
							VGap = 0.0
							HAlign = 'center'
						]
						children = #[
							new SCompartment[
								id = idCache.uniqueId(theId + '.comp.items')
								type = 'comp.box'
								layout = 'vbox'
								layoutOptions = new LayoutOptions[
									paddingLeft = 10.0
									paddingRight = 10.0
									paddingTop = 10.0
									paddingBottom = 10.0
									HGap = 10.0
									HAlign = 'left'
								
								]
								val elements = viewpoint.detail?.testItems?.elements
 								children = if (elements !== null) {
									#[
										new SLabel[
											id = idCache.uniqueId(theId + '.testItems')
											text = '' + elements.size
										].trace(viewpoint)
									]
								} else {
									#[]
								}
							],
							new SCompartment[
								id = idCache.uniqueId(theId + '.comp.risk')
								type = 'comp.box'
								layout = 'vbox'
								layoutOptions = new LayoutOptions[
									paddingLeft = 10.0
									paddingRight = 10.0
									paddingTop = 0.0
									paddingBottom = 0.0
									HAlign = 'right'
								]

								val risk = viewpoint.detail?.qualityRisk
								children = if (risk !== null) {
									#[
										new SLabel[
											id = idCache.uniqueId(theId + '.qualityRisk.imp')
											text = 'Imp: ' + risk.importance
										].trace(viewpoint),
										new SLabel[
											id = idCache.uniqueId(theId + '.qualityRisk.sev')
											text = 'Sev: ' + risk.severity
										].trace(viewpoint)
									]
								} else {
									#[]
								}
							].trace(viewpoint)
						]
					].trace(viewpoint),
					new SLabel [
						id = idCache.uniqueId(theId + '.coverage')
						text = viewpoint.detail?.coverage ?: ''
					].trace(viewpoint)
				]
			].trace(viewpoint)
		]).traceAndMark(viewpoint, context)
	}
	
	def dispatch TestElement toTestElement(TargetRef targetRef) {
		targetRef.ref	
	}
	
	def dispatch TestElement toTestElement(ViewpointRef viewpointRef) {
		viewpointRef.ref
	}

	def dispatch SEdge toSEdge(Relation relation, extension Context context) {
		new SEdge [
			type = 'edge.relation'
			sourceId = idCache.getId(relation.src.toTestElement)
			targetId = idCache.getId(relation.dst.toTestElement)
			val theId = idCache.uniqueId(relation, sourceId + ':----:' + targetId)
			id = theId
			children =  if (relation.stereotype !== null) {
				#[
					new SLabel [
						id = idCache.uniqueId(theId + '.label')
						type = 'label:xref'
						text = relation.stereotype
					].trace(relation, LanguagePackage.Literals.RELATION__DST, -1)
				]
			} else {
				#[]
			}
		].traceAndMark(relation, context)
	}

	def dispatch toSuper(Inheritance1 inheritance) {
		inheritance.superNode			
	}
	def dispatch toSub(Inheritance1 inheritance) {
		inheritance.sub.toTestElement
	}
	def dispatch toSuper(Inheritance2 inheritance) {
		inheritance.superNode
	}
	def dispatch toSub(Inheritance2 inheritance) {
		inheritance.sub
	}

	def dispatch SEdge toSEdge(Inheritance inheritance, extension Context context) {
		new SEdge [
			sourceId = idCache.getId(inheritance.toSub)
			targetId = idCache.getId(inheritance.toSuper)
			val theId = idCache.uniqueId(inheritance, sourceId + ':<|--:' + targetId)
			type = 'edge.inheritance'
			id = theId
			children =  if (inheritance.stereotype !== null) {
				#[
					new SLabel [
						id = idCache.uniqueId(theId + '.label')
						type = 'label:xref'
						text = inheritance.stereotype
					].trace(inheritance, LanguagePackage.Literals.INHERITANCE__NAME, -1)
				]
			} else {
				#[]
			}
		].traceAndMark(inheritance, context)
	}
		
	def dispatch SEdge toSEdge(Dependency dependency, extension Context context) {
		new SEdge [
			type = 'edge.dependency'
			sourceId = idCache.getId(dependency.src.toTestElement)
			targetId = idCache.getId(dependency.dst.toTestElement)
			val theId = idCache.uniqueId(dependency, sourceId + ':<--:' + targetId)
			id = theId
			children =  if (dependency.stereotype !== null) {
				#[
					new SLabel [
						id = idCache.uniqueId(theId + '.label')
						type = 'label:xref'
						text = dependency.stereotype
					].trace(dependency, LanguagePackage.Literals.DEPENDENCY__DST, -1)
				]
			} else {
				#[]
			}
		].traceAndMark(dependency, context)
	}

	def <T extends SModelElement> T traceAndMark(T sElement, EObject element, Context context) {
		sElement.trace(element).addIssueMarkers(element, context) 
	}
}